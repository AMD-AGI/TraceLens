# TreePerf

TreePerf is a Python SDK that works in conjunction with the Trace2Tree project. PyTorch generates a trace JSON file during profiling, which Trace2Tree parses into a tree data structure representing hierarchical dependencies between CPU operations and GPU kernel executions. TreePerf builds on this tree structure to compute performance metrics at both the model and operation levels. It enables users to analyze, interpret, and optimize AI models by providing detailed performance insights essential for architectural design and performance optimization.

---
## Key Ideas

Key Ideas
1. Tree Structure for GPU Execution Analysis: The hierarchical tree structure, generated by Trace2Tree, enables straightforward computation of GPU execution times. By linking CPU operations to their corresponding GPU kernel launches, it allows seamless aggregation of kernel execution times and performance metrics at various levels of granularity.
2. Performance Metrics from JSON Parsing: Metrics such as FLOPS and FLOPS/Byte are derived by extracting operation parameters from the JSON event data structure. These parameters are parsed and fed into performance models, enabling precise computation of performance metrics. 

---

## Key Featues

1. **Model-Level Summarised Analysis**: Provides a high-level view of performance metrics aggregated by model components for informed architectural design decisions.
Example output:

| Name               | Kernel time (ms) | Percent Total |
|--------------------|------------------|---------------|
| Conv backbone fwd  | 203.257          | 9.41%         |
| Conv backbone bwd  | 414.32           | 19.18%        |
| Transformer fwd    | 297.84           | 13.79%        |
| Transformer bwd    | 950.451          | 44.01%        |
| Decoder fwd        | 10.326           | 0.48%         |
| Decoder bwd        | 283.447          | 13.12%        |
| Total              | 2159.641         | 100.00%       |

2. **Detailed Operation Metrics**: Computes fine-grained performance metrics such as FLOPS, kernel time, and efficiency, enabling deep dives into specific operations.
Example output for aten::linear

| Operation     | M      | N      | K      | Bias  | GFLOPS   | FLOPS/Byte | TFLOPS/s | Total Kernel Time (µs) |
|---------------|--------|--------|--------|-------|----------|------------|----------|------------------|
| aten::linear  | 40960  | 1536   | 1536   | True  | 193.34   | 754.10     | 261.34   | 73298            |
| aten::linear  | 40960  | 6144   | 1536   | True  | 773.16   | 1193.10    | 364.54   | 50908            |
| aten::linear  | 40960  | 1536   | 6144   | True  | 773.35   | 1193.38    | 438.27   | 42408            |
| aten::linear  | 41400  | 1536   | 1536   | True  | 195.41   | 754.25     | 151.98   | 2572             |
| aten::linear  | 48000  | 64     | 1536   | True  | 9.51     | 61.84      | 27.97    | 340              |

3. **Backward and Forward Pass Metrics** - 
Leverages the hierarchical linking provided by Trace2Tree to compute metrics for both forward and backward passes, enabling support for training performance analysis.

4. **Extensible Operation Support**: Adding new operations is simple:
    - Parse operation shapes from the JSON trace.
    - Write the performance model (FLOPS, bytes).
    - Map the operation in the torch_op_mapping.py file.
- Current supported operations:
    - aten::linear
    - FlashAttnFunc (SDPA)
    - aten::conv2d
    - aten::conv3d

## Quick start
**Example 1: Parse a Trace and Compute Kernel Time**
```python
path = "/path/to/profile.json"
with open(path, 'r') as f:
    data = json.load(f)

events = data['traceEvents']
tree = TraceToTree(events)
tree.build_tree(add_python_func=True)
perf_analyzer = TreePerfAnalyzer(tree)

event = next(event for event in tree.events if event['name'] == 'model/model.py(173): backbone_forward')
fwd_conv_backbone_kernel_time,_ = perf_analyzer.agg_kernels_in_subtree(event['UID'])
```
**Example 2: Compute Performance Metrics for a Specific Operation**
```python
linear_root_nodes = [node for node in tree.cpu_root_nodes if tree.events_by_uid[node]['name'] == 'aten::linear']
uid = linear_root_nodes[0]
event = tree.events_by_uid[uid]
perf_analyzer.compute_fwd_perf_metrics(event)
```
output:
```
{'GFLOPS': 193.34,
 'Kernel Time (µs)': 778,
 'TFLOPS/s': 248.50,
 'Non-Data-Mov Kernel Time (µs)': 480,
 'Non-Data-Mov TFLOPS/s': 402.78,
 'FLOPS/Byte': 754.10,
 'param: M': 40960,
 'param: N': 1536,
 'param: K': 1536,
 'param: bias': True}
```